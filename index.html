<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Note </title>
    <link rel="icon" type="image/png" href="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTBhNrAUUBuQrInQ2dWlk_8C7v9GkUmwJ0z1X8gYkR7gy-YkLfLyy_et0w&s=10">
    <!-- Load compromise from CDN for POS highlighting -->
    <script src="https://unpkg.com/compromise"></script>
    <!-- Load jscolor for the color picker -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.5.2/jscolor.min.js"></script>

<style>
    /* --- Base Layout --- */
    html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: sans-serif;
        background-color: #121212;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Prevent body scrollbars */
    }

    /* --- Top Ribbon for Controls --- */
    #ribbon {
        flex-shrink: 0;
        background-color: #121212;
        padding: 8px;
        border-bottom: 1px solid #2c2c2c;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    #central-controls {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    #category-input {
        border-radius: 4px;
        border: 1px solid #4a4a4a;
        background-color: #333;
        color: #f0f0f0;
        padding: 6px 10px;
    }
    
    .category-select-wrapper {
        position: relative;
        width: 143px;
        height: 30.5px; 
    }

    #category-dropdown {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        border: none;
        background: transparent;
        width: 100%;
        height: 100%;
        cursor: pointer;
        border-radius: 4px; 
    }

    .category-select-wrapper::before {
        content: '';
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        z-index: 0;
        pointer-events: none;
        background-color: #333333;
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        transition: background-color 0.2s;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23f0f0f0'%3E%3Cpath d='M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: center;
        background-size: 18px 18px;
    }
    
    .category-select-wrapper:hover::before {
        background-color: #444444;
    }

    /* Shared button styles */
    #read-aloud-btn, #copy-btn, #clear-btn, #save-note-btn, #print-btn, #focus-btn, #pos-highlight-btn {
        background-color: #333333;
        color: #f0f0f0;
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        min-width: 50px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s, color 0.2s;
        white-space: nowrap;
        padding: 6px 15px; /* Common padding */
    }
    
    #read-aloud-btn, #focus-btn, #pos-highlight-btn {
        padding: 6px 42.5px; 
    }

    #copy-btn, #clear-btn, #save-note-btn, #print-btn {
        padding: 6px 38.25px;
    }
    
    .counter-display {
        background-color: #333333;
        color: #f0f0f0;
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        padding: 6px 10px;
        width: 120px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        cursor: default;
        white-space: nowrap;
        text-align: center;
    }

    #read-aloud-btn:hover, #copy-btn:hover, #save-note-btn:hover, #print-btn:hover, #focus-btn:hover, #pos-highlight-btn:hover {
        background-color: #444444;
    }
    
    #clear-btn:hover {
        background-color: #a13333;
    }
    
    #read-aloud-btn svg, #copy-btn svg, #clear-btn svg, #save-note-btn svg, #print-btn svg, #focus-btn svg, #pos-highlight-btn svg {
        width: 16px;
        height: 16px;
        fill: #f0f0f0;
        transition: opacity 0.2s ease-in-out;
    }
    
    #focus-btn svg, #pos-highlight-btn svg {
        opacity: 0.4; 
    }

    #focus-btn.active svg, #pos-highlight-btn.active svg {
        opacity: 1; 
    }
    
    #save-note-btn svg {
        margin-right: 0;
    }

    .icon-pause { display: none; }
    #read-aloud-btn.is-playing .icon-play { display: none; }
    #read-aloud-btn.is-playing .icon-pause { display: block; }

    /* --- Main Content Area --- */
    #main-content {
        flex-grow: 1; 
        display: flex;
        overflow: hidden;
    }

    /* --- Sidebar for Saved Notes --- */
    #sidebar {
        flex-basis: 30%; 
        flex-shrink: 0;
        background-color: #121212; 
        border-right: 1px solid #2c2c2c;
        display: flex;
        flex-direction: column;
        transition: flex-basis 0.3s ease; 
    }
    #sidebar.hidden {
        flex-basis: 0; 
        overflow: hidden;
    }
    #sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        border-bottom: 1px solid #2c2c2c;
        color: #f0f0f0;
        flex-shrink: 0;
    }
    #sidebar-header h2 {
        margin: 0;
        font-size: 1.2em;
    }
    #delete-all-btn {
        background-color: #a13333;
        color: #f0f0f0;
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 0.2s, color 0.2s, padding 0.2s, font-size 0.2s;
    }
    #delete-all-btn:hover {
        background-color: #8B0000;
    }
    #saved-notes-list {
        flex-grow: 1;
        overflow-y: auto;
        padding: 10px;
        color: #f0f0f0;
    }
    .note-item { 
        background-color: #1e1e1e;
        padding: 15px; 
        border-radius: 4px; 
        margin-bottom: 10px; 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        gap: 10px; 
        border-left: 3px solid transparent;
        transition: background-color 0.2s, border-color 0.2s;
    }
    .note-item.active {
        background-color: #2a2a3a;
        border-left: 3px solid #6a6aff;
    }
    .note-item p { margin: 0; flex-grow: 1; white-space: pre-wrap; word-break: break-all; font-size: 14px; }
    .note-item-actions { display: flex; gap: 8px; flex-shrink: 0; }
    .note-item-actions button { 
        background-color: #333333; 
        color: #f0f0f0; 
        border: 1px solid #4a4a4a; 
        border-radius: 4px; 
        padding: 5px 10px; 
        cursor: pointer; 
    }
    .note-item-actions button.delete-note-btn { background-color: #a13333; }
    .note-item-actions button:hover { background-color: #444444; }
    .note-item-actions button.delete-note-btn:hover { background-color: #8B0000; } 

    .category-group h3 {
        color: #a9a9a9;
        margin-top: 20px;
        margin-bottom: 10px;
        border-bottom: 1px solid #2c2c2c;
        padding-bottom: 5px;
    }

    #category-filter {
        width: calc(100% - 20px);
        padding: 8px;
        background-color: #333;
        color: #f0f0f0;
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        margin: 10px;
    }
    
    #category-dropdown option, #category-filter option {
        background: #333;
        color: #f0f0f0;
        padding: 4px;
    }

    /* --- Notepad Area --- */
    #notepad {
        flex-grow: 1;
        box-sizing: border-box;
        outline: none;
        overflow-y: auto; 
        padding: 25px;
        background-color: #1e1e1e;
        color: #f0f0f0;
        font-family: 'Courier New', Courier, monospace;
        font-size: 16px;
        line-height: 1.6;
        white-space: pre-wrap;
        word-wrap: break-word;
    }
    #notepad:empty::before {
        content: "Start writing... Use the save button to keep your notes permanently.";
        color: #666666;
        pointer-events: none;
    }
    
    .highlight-word, .highlight-sentence {
        border-radius: 3px;
        transition: background-color 0.2s ease-in-out;
    }
    .highlight-word { background-color: rgba(30, 80, 180, 0.6); }
    .highlight-sentence { background-color: rgba(180, 130, 30, 0.5); box-shadow: 0 0 5px rgba(180, 130, 30, 0.4); }

    .sentence {
        transition: opacity 0.3s ease-in-out;
        display: inline;
    }
    .dimmed {
        opacity: 0.4;
    }

    /* --- POS highlight colors --- */
    .POS-NN, .POS-NNP, .POS-NNS, .POS-NNPS { color: #b05e00; }  /* nouns - brown/orange */
    .POS-VB, .POS-VBD, .POS-VBG, .POS-VBN, .POS-VBP, .POS-VBZ { color: #006400; } /* verbs - dark green */
    .POS-JJ, .POS-JJR, .POS-JJS { color: #0000cd; } /* adjectives - blue */
    .POS-RB, .POS-RBR, .POS-RBS { color: #c71585; } /* adverbs - medium violet red */
    .POS-PRP, .POS-PRP$ { color: #555555; } /* pronouns - dark gray */
    .POS-IN { color: #8a2be2; } /* prepositions/subordinating conjunctions - blue violet */
    .POS-CC { color: #d81b60; } /* coordinating conjunctions - strong pink */
    .POS-DT { color: #6c757d; } /* determiners - gray */
    .POS-CD { color: #ff1493; } /* cardinal numbers - deep pink */
    .POS-TO { color: #2e8b57; } /* to - sea green */
    .POS-POS { color: #a0522d; } /* possessive ending - sienna */
    .POS-EX { color: #008b8b; } /* existential there - dark cyan */
    .POS-MD { color: #00ced1; } /* modals - dark turquoise */
    .POS-UH { color: #b8860b; } /* interjections - dark goldenrod */
    .POS-WDT, .POS-WP, .POS-WP$, .POS-WRB { color: #483d8b; } /* wh- words - dark slate blue */
    .POS-PUNC { color: inherit; } /* punctuation stays default color */

    /* token span styling */
    .tok { padding: 1px 2px; border-radius: 3px; }
    
    /* --- POS Settings Popup --- */
    #pos-settings-popup {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 400px;
        background-color: #2c2c2c;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        color: #f0f0f0;
    }
    #pos-settings-header {
        padding: 15px;
        border-bottom: 1px solid #4a4a4a;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #pos-settings-header h2 {
        margin: 0;
        font-size: 1.2em;
    }
    #pos-settings-close-btn {
        background: none;
        border: none;
        color: #f0f0f0;
        font-size: 1.5em;
        cursor: pointer;
    }
    #pos-settings-content {
        padding: 15px;
        max-height: 400px;
        overflow-y: auto;
    }
    .pos-setting {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    .pos-setting label {
        display: flex;
        align-items: center;
    }
    .pos-setting input[type="checkbox"] {
        margin-right: 10px;
    }

</style>
</head>
<body>

<!-- Ribbon for controls -->
<div id="ribbon">
    <div id="counter-container">
        <div id="word-count-display" class="counter-display">0 Words</div>
    </div>
    <div id="central-controls">
        <input type="text" id="category-input" placeholder="Enter or select category">
        <div class="category-select-wrapper" title="Select category">
            <select id="category-dropdown"></select>
        </div>
        <button id="save-note-btn" title="Save current note">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>
        </button>
         <!-- NEW POS HIGHLIGHT BUTTON -->
        <button id="pos-highlight-btn" title="Toggle Part-of-Speech Highlighting">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
        </button>
        <button id="focus-btn" title="Toggle sentence focus">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"/></svg>
        </button>
        <button id="read-aloud-btn" title="Read text aloud">
            <svg class="icon-play" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7z"/></svg>
            <svg class="icon-pause" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
        </button>
        <button id="copy-btn" title="Copy all text">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zM8 21V7h11v14H8z"/></svg>
        </button>
        <button id="print-btn" title="Print note">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z"/></svg>
        </button>
        <button id="clear-btn" title="Clear all text">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
        </button>
    </div>
</div>

<!-- Main content area with sidebar and notepad -->
<div id="main-content">
    <div id="sidebar">
        <div id="sidebar-header">
            <h2>Saved Notes</h2>
            <button id="delete-all-btn" title="Delete all notes">Delete All</button>
        </div>
        <select id="category-filter" title="Filter notes by category"></select>
        <div id="saved-notes-list">
            <!-- Saved notes will be rendered here by JavaScript -->
        </div>
    </div>
    <div id="notepad" contenteditable="true" spellcheck="false"></div>
</div>

<!-- POS Settings Popup -->
<div id="pos-settings-popup">
    <div id="pos-settings-header">
        <h2>POS Highlighting Settings</h2>
        <button id="pos-settings-close-btn">&times;</button>
    </div>
    <div id="pos-settings-content">
        <!-- POS settings will be rendered here by JavaScript -->
    </div>
</div>


<script>
    window.addEventListener('DOMContentLoaded', (event) => {
        // Main elements
        const notepad = document.getElementById('notepad');
        
        // Button elements
        const readAloudBtn = document.getElementById('read-aloud-btn');
        const clearBtn = document.getElementById('clear-btn');
        const copyBtn = document.getElementById('copy-btn');
        const saveNoteBtn = document.getElementById('save-note-btn');
        const printBtn = document.getElementById('print-btn');
        const focusBtn = document.getElementById('focus-btn');
        const posHighlightBtn = document.getElementById('pos-highlight-btn');
        
        // Sidebar elements
        const savedNotesList = document.getElementById('saved-notes-list');
        const deleteAllBtn = document.getElementById('delete-all-btn');
        const categoryFilter = document.getElementById('category-filter');
        const categoryInput = document.getElementById('category-input');
        const categoryDropdown = document.getElementById('category-dropdown');
        
        // Counter elements
        const wordCountDisplay = document.getElementById('word-count-display');

        // POS Settings Popup elements
        const posSettingsPopup = document.getElementById('pos-settings-popup');
        const posSettingsContent = document.getElementById('pos-settings-content');
        const posSettingsCloseBtn = document.getElementById('pos-settings-close-btn');

        // State tracking variables
        let currentlyEditingId = null; 
        const originalSaveButtonContent = saveNoteBtn.innerHTML;
        let isDimmingEnabled;
        let isPosHighlightingEnabled; // Default will be set in loadSettings
        let isProcessingInput = false;
        let renderTimer;

        // Speech synthesis state
        let currentUtterance = null;
        // ***** MODIFICATION: Use character index for speech highlighting *****
        let speechHighlightCharIndex = -1;

        // POS settings
        let posSettings = {};

        // --- Initial Setup ---
        function loadSettings() {
            const savedDimmingSetting = localStorage.getItem('dimmingEnabled');
            isDimmingEnabled = savedDimmingSetting === null ? true : savedDimmingSetting === 'true';
            
            if (isDimmingEnabled) {
                focusBtn.classList.add('active');
            }
            
            const savedPosHighlighting = localStorage.getItem('posHighlightingEnabled');
            isPosHighlightingEnabled = savedPosHighlighting === 'true'; // Default to false if not found
            posHighlightBtn.classList.toggle('active', isPosHighlightingEnabled);


            // Load POS settings from localStorage or set defaults
            const savedPosSettings = JSON.parse(localStorage.getItem('posSettings'));
            if (savedPosSettings) {
                posSettings = savedPosSettings;
            } else {
                // Default settings
                posSettings = {
                    'Nouns': { enabled: true, color: '#b05e00' },
                    'Verbs': { enabled: true, color: '#006400' },
                    'Adjectives': { enabled: true, color: '#0000cd' },
                    'Adverbs': { enabled: true, color: '#c71585' },
                    'Pronouns': { enabled: true, color: '#555555' },
                    'Prepositions': { enabled: true, color: '#8a2be2' },
                    'Conjunctions': { enabled: true, color: '#d81b60' },
                    'Determiners': { enabled: true, color: '#6c757d' },
                    'Numbers': { enabled: true, color: '#ff1493' },
                    'To': { enabled: true, color: '#2e8b57' },
                    'Possessives': { enabled: true, color: '#a0522d' },
                    'Existential': { enabled: true, color: '#008b8b' },
                    'Modals': { enabled: true, color: '#00ced1' },
                    'Interjections': { enabled: true, color: '#b8860b' },
                    'Wh-words': { enabled: true, color: '#483d8b' },
                };
            }
        }
        
        loadSettings();
        renderPosSettingsPopup();
        scheduleRender();
        renderSavedNotes(); 
        renderCategoryDropdowns();
        
        // --- Event Listeners ---
        
        notepad.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent default action to have full control

                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const range = selection.getRangeAt(0);
                range.deleteContents(); // Deletes selected text if any

                // Check if we are at the very beginning of the note
                const isFirstLine = !notepad.innerText.includes('\n');
                
                // Use original logic for multi-line jump, but only on the first line
                const textToInsert = isFirstLine ? '\n'.repeat(11) : '\n';
                const textNode = document.createTextNode(textToInsert);
                
                range.insertNode(textNode);

                // Create a new range to position the cursor correctly
                const newRange = document.createRange();
                // Set the cursor position right after the first inserted newline character
                newRange.setStart(textNode, 1); 
                newRange.collapse(true); // Collapse the range to a single point (the cursor)

                // Apply the new cursor position
                selection.removeAllRanges();
                selection.addRange(newRange);
                
                // Manually trigger the input event so that highlighting and word count can update
                notepad.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            }
        });

        notepad.addEventListener('keyup', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'PageUp', 'PageDown', 'Home', 'End'].includes(e.key)) {
                scheduleRender();
            }
            setTimeout(adjustNotepadScroll, 0); 
        });

        notepad.addEventListener('input', () => {
             if (speechSynthesis.speaking && currentUtterance) {
                speechSynthesis.cancel();
                removeHighlight();
                readAloudBtn.classList.remove('is-playing');
                currentUtterance = null;
            }
            scheduleRender();
        });

        notepad.addEventListener('click', () => {
            if (posSettingsPopup.style.display === 'block') {
                posSettingsPopup.style.display = 'none';
            }
            scheduleRender();
            adjustNotepadScroll();
        });
        
        clearBtn.addEventListener('click', () => {
            if (speechSynthesis.speaking) speechSynthesis.cancel();
            notepad.innerText = '';
            resetEditingState();
            scheduleRender();
        });

        posHighlightBtn.addEventListener('click', () => {
            isPosHighlightingEnabled = !isPosHighlightingEnabled;
            localStorage.setItem('posHighlightingEnabled', isPosHighlightingEnabled); // Save the state
            posHighlightBtn.classList.toggle('active', isPosHighlightingEnabled);
            
            if (isPosHighlightingEnabled) {
                posSettingsPopup.style.display = 'block';
            } else {
                posSettingsPopup.style.display = 'none';
            }
            scheduleRender();
        });

        posSettingsCloseBtn.addEventListener('click', () => {
            posSettingsPopup.style.display = 'none';
        });
        
        focusBtn.addEventListener('click', () => {
            isDimmingEnabled = !isDimmingEnabled;
            localStorage.setItem('dimmingEnabled', isDimmingEnabled);
            focusBtn.classList.toggle('active', isDimmingEnabled);
            scheduleRender();
        });

        savedNotesList.addEventListener('click', (e) => {
            const notes = JSON.parse(localStorage.getItem('myNotes') || '[]');
            const target = e.target.closest('button');
            if (!target) return;

            const noteId = target.dataset.id;
            const noteToLoad = notes.find(note => note.id === noteId);

            if (target.classList.contains('load-note-btn')) {
                notepad.innerText = noteToLoad.text;
                categoryInput.value = noteToLoad.category || '';
                currentlyEditingId = noteId; 
                saveNoteBtn.innerHTML = '<span>Update</span>'; 
                saveNoteBtn.title = "Update the current note";
                renderSavedNotes(categoryFilter.value); 
                scheduleRender();
            }
            
            if (target.classList.contains('delete-note-btn')) {
                if (confirm('Are you sure you want to delete this note?')) {
                    if (currentlyEditingId === noteId) {
                       notepad.innerText = '';
                       resetEditingState();
                       scheduleRender();
                    }
                    const updatedNotes = notes.filter(note => note.id !== noteId);
                    localStorage.setItem('myNotes', JSON.stringify(updatedNotes));
                    renderSavedNotes(categoryFilter.value);
                    renderCategoryDropdowns();
                }
            }
        });
        
        deleteAllBtn.addEventListener('click', () => {
            const notes = JSON.parse(localStorage.getItem('myNotes') || '[]');
            const selectedCategory = categoryFilter.value;

            if (selectedCategory) {
                const notesInCategory = notes.filter(note => note.category === selectedCategory).length;
                if (notesInCategory === 0) {
                    alert(`There are no notes in the "${selectedCategory}" category to delete.`);
                    return;
                }
                if (confirm(`Are you sure you want to delete all ${notesInCategory} notes in the "${selectedCategory}" category? This action cannot be undone.`)) {
                    if(currentlyEditingId) {
                        const noteBeingEdited = notes.find(n => n.id === currentlyEditingId);
                        if(noteBeingEdited && noteBeingEdited.category === selectedCategory) {
                            notepad.innerText = '';
                            resetEditingState();
                            scheduleRender();
                        }
                    }
                    const updatedNotes = notes.filter(note => note.category !== selectedCategory);
                    localStorage.setItem('myNotes', JSON.stringify(updatedNotes));
                    categoryFilter.value = '';
                    updateDeleteButtonState();
                    renderSavedNotes();
                    renderCategoryDropdowns();
                }
            } else {
                if (notes.length === 0) {
                    alert('There are no notes to delete.');
                    return;
                }
                if (confirm('Are you sure you want to delete ALL saved notes? This action cannot be undone.')) {
                    localStorage.removeItem('myNotes');
                    notepad.innerText = '';
                    resetEditingState();
                    scheduleRender();
                    renderSavedNotes();
                    renderCategoryDropdowns();
                }
            }
        });

        categoryDropdown.addEventListener('change', () => categoryInput.value = categoryDropdown.value);
        
        categoryFilter.addEventListener('change', () => {
            const selectedCategory = categoryFilter.value;
            categoryInput.value = selectedCategory;
            updateDeleteButtonState();
            renderSavedNotes(selectedCategory);
        });

        readAloudBtn.addEventListener('click', () => {
            if (speechSynthesis.speaking && !speechSynthesis.paused) {
                speechSynthesis.pause();
                readAloudBtn.classList.remove('is-playing');
                readAloudBtn.title = "Resume reading";
                return;
            }
            if (speechSynthesis.paused) {
                speechSynthesis.resume();
                readAloudBtn.classList.add('is-playing');
                readAloudBtn.title = "Pause reading";
                return;
            }
            const textToRead = notepad.innerText;
            if (textToRead.trim() === '') {
                alert("There is no text to read.");
                return;
            }
            
            removeDimming(); 
            removeHighlight();
            
            currentUtterance = new SpeechSynthesisUtterance(textToRead);
            
            // ***** FIX: Add and correct event listeners for highlighting *****
            currentUtterance.onstart = () => {
                readAloudBtn.classList.add('is-playing');
                readAloudBtn.title = "Pause reading";
                speechHighlightCharIndex = 0; // Start highlight at the beginning
                scheduleRender();
            };
            currentUtterance.onboundary = (event) => {
                speechHighlightCharIndex = event.charIndex;
                scheduleRender();
            };
            currentUtterance.onend = () => {
                removeHighlight(); // Clears index and triggers re-render
                readAloudBtn.classList.remove('is-playing');
                readAloudBtn.title = "Read text aloud";
                currentUtterance = null;
            };
            currentUtterance.onerror = (event) => {
                console.error('SpeechSynthesisUtterance.onerror', event);
                removeHighlight(); // Also clear highlight on error
                readAloudBtn.classList.remove('is-playing');
                readAloudBtn.title = "Read text aloud";
                currentUtterance = null;
            };
            
            speechSynthesis.cancel(); 
            speechSynthesis.speak(currentUtterance);
        });
        
        copyBtn.addEventListener('click', () => {
            const textToCopy = notepad.innerText;
            if (textToCopy.trim() === '') {
                alert("There is nothing to copy.");
                return;
            }
            navigator.clipboard.writeText(textToCopy).then(() => {
                const originalContent = copyBtn.innerHTML;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => copyBtn.innerHTML = originalContent, 1500);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Could not copy text to clipboard.');
            });
        });
        
        printBtn.addEventListener('click', () => {
            const notepadText = notepad.innerText.trim();
            const selectedCategory = categoryFilter.value;

            if (notepadText === '' && selectedCategory) {
                const notes = JSON.parse(localStorage.getItem('myNotes') || '[]');
                const notesToPrint = notes.filter(note => note.category === selectedCategory);

                if (notesToPrint.length === 0) {
                    alert(`There are no notes in the "${selectedCategory}" category to print.`);
                    return;
                }
                
                let combinedNotesHtml = `<h1>${selectedCategory}</h1>`; 
                notesToPrint.forEach((note, index) => {
                    if (index > 0) combinedNotesHtml += `<hr style="border-top: 1px dashed #ccc; margin: 20px 0;">`;
                    combinedNotesHtml += `<pre>${note.text}</pre>`;
                });
                printContent(combinedNotesHtml);

            } else {
                if (notepadText === '') {
                    alert("There is nothing to print.");
                    return;
                }
                printContent('<pre>' + notepadText + '</pre>');
            }
        });
        
        saveNoteBtn.addEventListener('click', () => {
            const noteText = notepad.innerText.trim();
            if (noteText === '') {
                alert('Cannot save an empty note.');
                return;
            }
            
            const notes = JSON.parse(localStorage.getItem('myNotes') || '[]');
            let message = 'Saved!';
            let category;

            if (currentlyEditingId !== null) {
                category = categoryInput.value.trim();
                const noteIndex = notes.findIndex(note => note.id === currentlyEditingId);
                if (noteIndex > -1) {
                    notes[noteIndex].text = noteText;
                    notes[noteIndex].category = category;
                    message = 'Updated!';
                }
            } else {
                category = categoryInput.value.trim();
                const newNote = { id: Date.now().toString(), text: noteText, category: category || 'Uncategorized' };
                notes.push(newNote);
            }
            
            localStorage.setItem('myNotes', JSON.stringify(notes));
            notepad.innerText = '';
            resetEditingState();
            scheduleRender();
            renderSavedNotes(categoryFilter.value); 
            renderCategoryDropdowns();

            saveNoteBtn.innerHTML = `<span>${message}</span>`;
            setTimeout(() => saveNoteBtn.innerHTML = originalSaveButtonContent, 1500);
        });

        // --- Core Rendering Logic ---
        function scheduleRender() {
            clearTimeout(renderTimer);
            renderTimer = setTimeout(() => {
                if (isProcessingInput) return;
                isProcessingInput = true;

                const plainText = notepad.innerText;
                const sel = saveSelection(notepad);

                if (isPosHighlightingEnabled) {
                    renderPOS(plainText);
                } else {
                    renderSentenceFocus(plainText);
                }
                
                restoreSelection(notepad, sel);
                updateCounts();
                adjustNotepadScroll();

                setTimeout(() => isProcessingInput = false, 0);
            }, 150);
        }

        // --- POS Highlighting Functions ---
        const escapeHTML = (s) => s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

        function getPosCategory(penn) {
            if (/^NN/.test(penn)) return 'Nouns';
            if (/^VB/.test(penn)) return 'Verbs';
            if (/^JJ/.test(penn)) return 'Adjectives';
            if (/^RB/.test(penn)) return 'Adverbs';
            if (/^PRP/.test(penn)) return 'Pronouns';
            if (penn === 'IN') return 'Prepositions';
            if (penn === 'CC') return 'Conjunctions';
            if (penn === 'DT') return 'Determiners';
            if (penn === 'CD') return 'Numbers';
            if (penn === 'TO') return 'To';
            if (penn === 'POS') return 'Possessives';
            if (penn === 'EX') return 'Existential';
            if (penn === 'MD') return 'Modals';
            if (penn === 'UH') return 'Interjections';
            if (/^W/.test(penn)) return 'Wh-words';
            return null;
        }

        function renderPOS(text) {
            if (text.trim() === '') {
                notepad.innerHTML = '';
                return;
            }

            const caretPos = getCaretPosition(notepad);
            let doc = nlp(text);
            if (doc.compute) {
                doc.compute('penn');
            }
            const sentencesJson = doc.json();
            
            let charCounter = 0;
            let activeSentenceIndex = -1;

            // Find the active sentence by character position
            for (let i = 0; i < sentencesJson.length; i++) {
                const sentenceText = sentencesJson[i].text || '';
                if (caretPos >= charCounter && caretPos <= charCounter + sentenceText.length) {
                    activeSentenceIndex = i;
                    break;
                }
                charCounter += sentenceText.length;
            }
            if (activeSentenceIndex === -1 && caretPos > 0) {
                 activeSentenceIndex = sentencesJson.length - 1;
            }
            
            charCounter = 0; // Reset for the rendering loop
            const finalHtmlParts = [];
            for (let i = 0; i < sentencesJson.length; i++) {
                const sentence = sentencesJson[i];
                const sentenceText = sentencesJson[i].text || '';
                const sentenceTermParts = [];

                if (sentence && sentence.terms) {
                    for (const term of sentence.terms) {
                        const textRaw = term.text || '';
                        const pre = term.pre || '';
                        const post = term.post || '';
                        const penn = term.penn || '';
                        const category = getPosCategory(penn);
                        const setting = category ? posSettings[category] : null;

                        if (setting && setting.enabled) {
                            const span = `<span class="tok" style="color: ${setting.color}" title="${penn}">${escapeHTML(textRaw)}</span>`;
                            sentenceTermParts.push(escapeHTML(pre) + span + escapeHTML(post));
                        } else {
                            sentenceTermParts.push(escapeHTML(pre) + escapeHTML(textRaw) + escapeHTML(post));
                        }
                    }
                }
                
                const sentenceHtml = sentenceTermParts.join('');
                
                // Determine classes for dimming and speech highlighting
                const isDimmed = isDimmingEnabled && (i !== activeSentenceIndex);
                let sentenceClasses = ['sentence'];
                if(isDimmed) sentenceClasses.push('dimmed');

                // ***** FIX: Check if this sentence should be highlighted for speech *****
                const isSpoken = speechHighlightCharIndex !== -1 && speechHighlightCharIndex >= charCounter && speechHighlightCharIndex < (charCounter + sentenceText.length);
                if (isSpoken) {
                    sentenceClasses.push('highlight-sentence');
                }

                finalHtmlParts.push(`<span class="${sentenceClasses.join(' ')}">${sentenceHtml}</span>`);
                charCounter += sentenceText.length; // Update character counter
            }

            notepad.innerHTML = finalHtmlParts.length > 0 ? finalHtmlParts.join('') : escapeHTML(text);
        }
        
        // --- Helper Functions ---

        function renderSentenceFocus(text) {
             const caretPos = getCaretPosition(notepad);
             if (text.trim() === '') {
                notepad.innerHTML = '';
                return;
             }

            const sentences = text.match(/([^\.!\?]+[\.!\?]*)/g) || [text];
            notepad.innerHTML = '';
            let currentPos = 0;
            let activeSentenceIndex = -1;
            
            // Find active sentence first
            sentences.forEach((s, index) => {
                if (caretPos >= currentPos && caretPos <= currentPos + s.length) {
                    activeSentenceIndex = index;
                }
                currentPos += s.length;
            });
            
            currentPos = 0; // Reset for rendering loop
            sentences.forEach((s, index) => {
                const span = document.createElement('span');
                let spanClasses = ['sentence'];
                
                // ***** FIX: Check for speech highlighting *****
                const isSpoken = speechHighlightCharIndex !== -1 && speechHighlightCharIndex >= currentPos && speechHighlightCharIndex < (currentPos + s.length);
                if (isSpoken) {
                    spanClasses.push('highlight-sentence');
                }
                
                // Add dimming class if needed
                if (isDimmingEnabled && index !== activeSentenceIndex) {
                    spanClasses.push('dimmed');
                }
                
                span.className = spanClasses.join(' ');
                span.textContent = s;
                notepad.appendChild(span);
                currentPos += s.length;
            });

        }

        function adjustNotepadScroll() {
            const selection = window.getSelection();
            if (!selection.rangeCount || !selection.isCollapsed) return;
            const range = selection.getRangeAt(0);
            const notepadRect = notepad.getBoundingClientRect();
            const tempSpan = document.createElement('span');
            tempSpan.textContent = '\u200B';
            range.insertNode(tempSpan);
            const caretRect = tempSpan.getBoundingClientRect();
            tempSpan.parentNode.removeChild(tempSpan);
            if (caretRect.bottom > notepadRect.bottom - 10) { 
                let lineHeight = parseFloat(window.getComputedStyle(notepad).lineHeight) || (16 * 1.6);
                const desiredMargin = 12 * lineHeight;
                const scrollAmount = (caretRect.bottom - notepadRect.bottom) + desiredMargin;
                notepad.scrollBy({ top: scrollAmount, behavior: 'smooth' });
            }
        }

        function removeDimming() {
            notepad.querySelectorAll('.sentence').forEach(s => s.classList.remove('dimmed'));
        }

        function saveSelection(containerEl) {
            const sel = window.getSelection();
            if (!sel || sel.rangeCount === 0) return null;
            const range = sel.getRangeAt(0);
            const preSelectionRange = range.cloneRange();
            preSelectionRange.selectNodeContents(containerEl);
            preSelectionRange.setEnd(range.startContainer, range.startOffset);
            const start = preSelectionRange.toString().length;
            return { start: start, end: start + range.toString().length };
        }

        function restoreSelection(containerEl, savedSel) {
            if (!savedSel) return;
            let charIndex = 0, range = document.createRange();
            range.setStart(containerEl, 0);
            range.collapse(true);
            const nodeStack = [containerEl];
            let node, foundStart = false, stop = false;

            while (!stop && (node = nodeStack.pop())) {
                if (node.nodeType === 3) {
                    const nextCharIndex = charIndex + node.length;
                    if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {
                        range.setStart(node, savedSel.start - charIndex);
                        foundStart = true;
                    }
                    if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {
                        range.setEnd(node, savedSel.end - charIndex);
                        stop = true;
                    }
                    charIndex = nextCharIndex;
                } else {
                    let i = node.childNodes.length;
                    while (i--) nodeStack.push(node.childNodes[i]);
                }
            }

            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }

        function getCaretPosition(element) {
            let caretOffset = 0;
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(element);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                caretOffset = preCaretRange.toString().length;
            }
            return caretOffset;
        }

        function setCaretPosition(element, offset) {
            const range = document.createRange();
            const sel = window.getSelection();
            range.selectNodeContents(element);
            range.collapse(true);
            let charIndex = 0;
            const nodeStack = [element];
            let node, foundStart = false;
            while (!foundStart && (node = nodeStack.pop())) {
                if (node.nodeType === 3) {
                    const nextCharIndex = charIndex + node.length;
                    if (offset >= charIndex && offset <= nextCharIndex) {
                        range.setStart(node, offset - charIndex);
                        foundStart = true;
                    }
                    charIndex = nextCharIndex;
                } else {
                    let i = node.childNodes.length;
                    while (i--) nodeStack.push(node.childNodes[i]);
                }
            }
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
        }

        function printContent(content) {
            const iframe = document.createElement('iframe');
            iframe.style.position = 'absolute';
            iframe.style.width = '0';
            iframe.style.height = '0';
            iframe.style.border = '0';
            iframe.style.left = '-9999px';
            iframe.onload = function() {
                try {
                    iframe.contentWindow.focus();
                    iframe.contentWindow.print();
                } catch (e) {
                    console.error('Print failed:', e);
                    alert('Could not open print dialog.');
                }
                setTimeout(() => document.body.removeChild(iframe), 500);
            };
            document.body.appendChild(iframe);
            const doc = iframe.contentWindow.document;
            doc.open();
            doc.write('<!DOCTYPE html><html><head><title>Print Note</title>');
            doc.write(`<style>@media print { @page { size: A4; margin: 2cm; } body { font-family: sans-serif; font-size: 12pt; color: #000; } h1 { font-size: 24pt; border-bottom: 2px solid #000; padding-bottom: 10px; margin-bottom: 30px; } pre { white-space: pre-wrap; word-wrap: break-word; font-family: 'Courier New', Courier, monospace; font-size: 11pt; page-break-inside: avoid;} hr { border: none; border-top: 1px dashed #ccc; margin: 40px 0; } }</style>`);
            doc.write('</head><body>' + content + '</body></html>');
            doc.close();
        }

        function updateDeleteButtonState() {
            const selectedCategory = categoryFilter.value;
            if (selectedCategory) {
                deleteAllBtn.textContent = `Delete Category`;
                deleteAllBtn.title = `Delete all notes in the '${selectedCategory}' category`;
            } else {
                deleteAllBtn.textContent = 'Delete All';
                deleteAllBtn.title = 'Delete all notes';
            }
        }

        function resetEditingState() {
            currentlyEditingId = null;
            if (!categoryFilter.value) categoryInput.value = '';
            saveNoteBtn.innerHTML = originalSaveButtonContent;
            saveNoteBtn.title = 'Save current note';
            const activeItem = savedNotesList.querySelector('.note-item.active');
            if (activeItem) activeItem.classList.remove('active');
        }

        function updateCounts() {
            const text = notepad.innerText.trim();
            const words = text.split(/\s+/g).filter(word => word.length > 0);
            const wordCount = text === '' ? 0 : words.length;
            wordCountDisplay.textContent = `${wordCount} ${wordCount === 1 ? 'Word' : 'Words'}`;
        }

        function renderCategoryDropdowns() {
            const notes = JSON.parse(localStorage.getItem('myNotes') || '[]');
            const categories = [...new Set(notes.map(note => note.category).filter(Boolean))].sort();
            const currentFilter = categoryFilter.value; 
            categoryDropdown.innerHTML = '<option value="" disabled selected>Category</option>';
            categoryFilter.innerHTML = '<option value="">All Categories</option>';
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryDropdown.appendChild(option.cloneNode(true));
                categoryFilter.appendChild(option);
            });
            categoryFilter.value = currentFilter; 
            updateDeleteButtonState();
        }

        function renderSavedNotes(filter = '') {
            const notes = JSON.parse(localStorage.getItem('myNotes') || '[]');
            savedNotesList.innerHTML = ''; 
            deleteAllBtn.style.display = notes.length > 0 ? 'block' : 'none';
            if (notes.length === 0) {
                savedNotesList.innerHTML = '<p style="padding: 10px; color: #666;">No saved notes found.</p>';
                return;
            }
            let filteredNotes = filter ? notes.filter(note => note.category === filter) : notes;
            const groupedNotes = filteredNotes.reduce((acc, note) => {
                const category = note.category || 'Uncategorized';
                if (!acc[category]) acc[category] = [];
                acc[category].push(note);
                return acc;
            }, {});
            const sortedCategories = Object.keys(groupedNotes).sort();
            if(sortedCategories.length === 0 && filter) {
                savedNotesList.innerHTML = `<p style="padding: 10px; color: #666;">No notes found in category: "${filter}"</p>`;
                return;
            }
            const displayCategories = filter ? [filter] : sortedCategories;
            displayCategories.forEach(category => {
                if (!groupedNotes[category]) return;
                const groupContainer = document.createElement('div');
                groupContainer.className = 'category-group';
                if (!filter) { 
                    const categoryTitle = document.createElement('h3');
                    categoryTitle.textContent = category;
                    groupContainer.appendChild(categoryTitle);
                }
                groupedNotes[category].forEach(note => {
                    const noteItem = document.createElement('div');
                    noteItem.className = 'note-item';
                    if (note.id === currentlyEditingId) noteItem.classList.add('active');
                    const noteText = document.createElement('p');
                    noteText.textContent = note.text.substring(0, 100) + (note.text.length > 100 ? '...' : '');
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'note-item-actions';
                    const loadBtn = document.createElement('button');
                    loadBtn.textContent = 'Load';
                    loadBtn.className = 'load-note-btn';
                    loadBtn.dataset.id = note.id;
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.className = 'delete-note-btn';
                    deleteBtn.dataset.id = note.id;
                    actionsDiv.appendChild(loadBtn);
                    actionsDiv.appendChild(deleteBtn);
                    noteItem.appendChild(noteText);
                    noteItem.appendChild(actionsDiv);
                    groupContainer.appendChild(noteItem);
                });
                savedNotesList.appendChild(groupContainer);
            });
        }

        // ***** FIX: Rewritten highlight removal logic *****
        function removeHighlight() {
            if (speechHighlightCharIndex !== -1) {
                speechHighlightCharIndex = -1;
                scheduleRender(); // Trigger a re-render to remove the highlight class
            }
        }
        
        function renderPosSettingsPopup() {
            posSettingsContent.innerHTML = '';
            for (const category in posSettings) {
                const setting = posSettings[category];
                const settingDiv = document.createElement('div');
                settingDiv.className = 'pos-setting';

                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = setting.enabled;
                checkbox.dataset.category = category;
                checkbox.addEventListener('change', (e) => {
                    posSettings[category].enabled = e.target.checked;
                    localStorage.setItem('posSettings', JSON.stringify(posSettings));
                    scheduleRender();
                });
                label.appendChild(checkbox);
                label.append(category);

                const colorInput = document.createElement('input');
                colorInput.dataset.jscolor = '{}';
                colorInput.value = setting.color;
                colorInput.dataset.category = category;
                colorInput.addEventListener('change', (e) => {
                    posSettings[category].color = e.target.value;
                    localStorage.setItem('posSettings', JSON.stringify(posSettings));
                    scheduleRender();
                });
                
                settingDiv.appendChild(label);
                settingDiv.appendChild(colorInput);
                posSettingsContent.appendChild(settingDiv);
            }
            jscolor.install();
        }
    });
</script>
</body>
</html>
